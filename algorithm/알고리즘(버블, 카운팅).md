# 알고리즘



## 1. 좋은 알고리즘이란?

1. 정확성 : 얼마나 정확하게 작동하는가?
2. 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가?
3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가?
4. 단순성 : 얼마나 단순한가?
5. 최적성 : 더 이상 개선할 여지없이 최적화되었는가?



## 2. 빅-오(O) 표기법

- 시간 복잡도 함수 중 가장 큰 영향력을 주는 n에 대한 항만을 표시하는 표기법
- 계수는 생략하여 표기한다.
- 가장 큰 영향을 미치는 것을 제외하고 모두 생략한다고 생각하면 된다!
- 예를 들어, 10n + 1000000 이라는 시간복잡도 함수가 있을경우 상수인 1000000과 n의 계수인 10을 모두 생략하고 O(n)으로 표기하는 방법이다.
  - n의 값이 10억과 같이 매우 큰 숫자가 들어가면 상수인 1000000이 전체값에 미치는 영향은 아주 미미함으로 생략하는 것이고, 계수인 10도 n보다 해당 함수에서 영향력이 적기에 생략한다.



## 3. 완전 검색

- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- Brute_force 혹은 generate-and-test 기법이라고도 불리운다.
- 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.



## 4. 단순하게 순열 생성하기

> {1, 2, 3}을 포함하는 모든 순열을 출력하는 코드를 작성하시오.

```python
# for문을 3중첩하여 중복되는 숫자없이 모든 순열을 만들기

# 1,2,3 이라는 숫자들을 활용하여 만들기 때문에 범위를 아래와 같이 지정한다.
for a in range(1, 4):
    for b in range(1, 4):
        # 중복되는 숫자없이 구현해야하므로 if문으로 중복되지 않도록 해준다.
        if b != a:
            # 앞에서 두 숫자가 동일한 숫자가 아닌채로 들어왔고
            # c는 앞서 들어온 a, b와 겹치면 안되므로
            for c in range(1, 4):
                if c != a and c != b:
                    print(a, b, c)
                    
# 결과
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```



## 5. 탐욕(Greedy) 알고리즘

- 여러 경우 중 하나를 결정해야 할 때마다 '그 순간'에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- '그 순간'에 이루어지는 결정은 그 당시엔 최적이지만, 모든 순간들이 지나갔을 때 그것이 최적이라는 보장은 없다.



## 6. 정렬

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순, ascending), 혹은 그 반대의 순서대로(내림차순, descending) 재배열하는 것

- 대표적인 정렬 방식의 종류
  1. 버블 정렬(Bubble Sort)
  2. 카운팅 정렬(Counting Sort)
  3. 선택 정렬(Selection Sort)
  4. 퀵 정렬(Quick Sort)
  5. 삽입 정렬(Insertion Sort)
  6. 병합 정렬(Merge Sort)



### 6-1. 버블 정렬(O(n^2))

- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

- 정렬 과정

  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
  - 한 단계가 끝나면(즉 첫 원소부터 마지막 원소까지 자리를 교환하는 단계) 가장 큰 원소가 마지막 자리로 정렬 된다.

-  [33, 5, 17, 14] 리스트를 버블 정렬하기!(글로만 표현해보기)

  1. 우선 첫번째 요소인 33과 두번째 요소인 5를 비교하였을 때 첫번째 요소인 33이 더 크므로, 33과 5의 위치를 바꾼다. => [5, 33, 17, 14]

  2. 두번째 요소인 33과 세번째 요소인 17을 비교하였을 때 두번째 요소인 33이 더 크므로, 33과 17의 위치를 바꾼다. => [5, 17, 33, 14]
  3. 세번째 요소인 33과 마지막 요소인 14를 비교하였을 때 세번째 요소인 33인 더 크므로, 33과 14의 위치를 바꾼다. => [5, 17, 14, 33]
  4. 리스트에 요소가 4개 들어있지만 비교는 총 3번을 하게된다.
  5. 한 단계가 끝났으니 다시 처음으로 돌아가서 위의 단계를 반복하는데, 한 단계가 끝날때마다 비교횟수는 1번씩 줄어들게 된다(왜냐하면 한 단계가 끝날때마다 가장 마지막 위치에 가장 큰 값이 있으므로 해당값과는 비교 할 필요가 없기 때문이다.)

```python
# 위의 버블정렬을 코드로 구현해보기
numbers = [33, 5, 17, 14]

# i의 시작이 0부터가아닌, 가장 마지막 인덱스값인 numbers라는 리스트의 길이(4) - 1 = 3부터
# i가 시작되고 한번 순회할때마다 i값인 1씩 줄어들어서 2, 1이 된다.
# 이 i값은 범위의 끝 위치를 나타낸다.
# 처음엔 끝 위치가 3번 인덱스이지만 한 단계가 끝나면 가장 마지막요소는 비교에서 제외해도 되기때문에(이미 제일 큰 값이 마지막에 있으니 비교할 필요가 없다) 2번 인덱스, 그 다음 단계가 끝나면 1번 인덱스로!
for i in range(len(numbers), 0, -1):
    # 첫번째 요소(0번 인덱스)부터 끝위치의 전까지(왜냐하면 요소와, 그 요소의 오른쪽 요소를 비교함으로)
    # j가 끝요소라면 오른쪽에 더이상 비교할 요소가 없어 index error가 발생한다.
    for j in range(0, i):
        # 값을 비교했을 때 더 큰값을 뒤쪽요소로!
        if numbers[j] > numbers[j+1]:
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
```



### 6-2. 카운팅 정렬(O(n+k), n은 리스트의 길이, k는 정수의 최댓값)

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

- 제한사항

  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능: 각 항목 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.
  - 카운트를 위한 공간 할당을 위해 집합 내 가장 큰 정수값을 알아야 한다.

- [0, 3, 2, 5, 1, 2, 4, 6] 리스트를 카운팅 정렬하기! (글로만 표현해보기)

  1. 우선 리스트의 요소값중 가장 큰 정수를 찾는다.(6)

  2. 정수값이 나온 횟수를 셀 0으로만 이루어진 counts리스트를 만든다. 이때 0의 갯수는 가장 큰 정수인 6에 1을 더한 7개의 0으로 이루어진다.(왜냐하면 0부터 세야하기 때문에 0, 1, 2, 3, 4, 5, 6의 정수가 몇번 나왔는지 셀 수 있도록 총 7개의 0으로 만들어야 한다.)

  3. 리스트를 순회하면서 각 요소의 값과 counts 리스트의 인덱스값과 같은 위치에 1을 더해준다.

  4. counts = [1, 1, 2, 1, 1, 1, 1]이 된다는 것을 알 수 있다. 각각 0은 1번, 1은 1번, 2는 2번... counts배열의 모든 값을 더하면 기존리스트의 길이와 똑같다는 걸 알 수 있다.

  5.  counts 리스트의 모든 요소들을 누적합으로 나타낸다. => [1, 2, 4, 5, 6, 7, 8]

  6. 새롭게 정렬된 리스트를 만들 원본 리스트와 동일한 길이의 리스트를 만든다. 

     TEMP = [0, 0, 0, 0, 0, 0, 0, 0]

  7. 원본 리스트의 가장 마지막 요소값을 확인하고(6) counts 리스트의 6번 인덱스 값을 하나 줄이고(8->7) 

     TEMP에 counts 배열에서 방금 전 줄인 값(7)의 인덱스 위치에 원본리스트의 요소(6)를 삽입한다.

  8. 위의 작업을 반복하면 TEMP가 완성된다.

```python
# 카운팅정렬 코드로 구현하기
# counting sort 구현
def counting_sort(array, max):
    # counting array 생성
    # 들어오는 max는 가장 큰 값을 의미하므로 +1을 해줘야 0도 셀수 있다!
    counting_array = [0] * (max + 1)

    # counting array에 들어온 array 내 원소의 빈도수 담기
    for i in array:
        counting_array[i] += 1

    # counting array 누적합으로 업데이트!
    for i in range(max):
        counting_array[i + 1] += counting_array[i]

    # output array 생성
    # 즉 정렬을 완성할 array를 생성하는 것(길이는 들어온 array와 같다)
    output_array = [-1] * len(array)

    # output array에 정렬하기(counting array를 참조)
    for i in range(len(array)-1, -1, -1):
        output_array[counting_array[array[i]] - 1] = array[i]
        counting_array[array[i]] -= 1
    return output_array

A = [1, 3, 2, 4, 3, 2]
print(counting_sort(A, 4))
```



